# Бинарное дерево поиска

## Описание

Реализация STL-совместимого контейнера `BinarySearchTree` с поддержкой трех стратегий обхода (in-order, pre-order, post-order) через итераторы. Контейнер параметризуется типом данных, компаратором и аллокатором, удовлетворяя требованиям STL для ассоциативных контейнеров.

## Особенности

- **Три стратегии обхода** через tag dispatch:
  - `InOrder` (симметричный)
  - `PreOrder` (прямой)
  - `PostOrder` (обратный)
- **Полная STL-совместимость**:
  - Контейнер и ассоциативный контейнер
  - Реверсивные итераторы
  - Поддержка аллокаторов
  - Двунаправленные итераторы
- **Расширенный интерфейс**:
  - Вставка, удаление, поиск
  - Слияние деревьев
  - Извлечение узлов
  - Поддержка пользовательских компараторов

## Структура проекта

```
lib/
    BinarySearchTree.h  # Основной класс контейнера
    Iterator.h          # Прямые итераторы
    ReverseIterator.h   # Реверсивные итераторы
    Node.h              # Узел дерева
    tag.cpp             # Тэги для dispatch
tests/
    binary_search_tree_test.cpp  # Тесты на Google Test
CMakeLists.txt          # Система сборки
```

## Пример использования

```cpp
#include "include/BinarySearchTree.h"

int main() {
    BinarySearchTree<int> bst;
    bst.insert(3);
    bst.insert(1);
    bst.insert(4);
    
    // Обход in-order
    for (auto it = bst.begin(); it != bst.end(); ++it) {
        std::cout << *it << " ";
    }
    
    // Использование алгоритмов STL
    auto found = std::find(bst.begin(), bst.end(), 3);
    if (found != bst.end()) {
        std::cout << "Found: " << *found;
    }
}
```

## Требования

- C++17 или новее
- Компилятор с поддержкой STL
- CMake 3.10+
- Google Test (автоматически загружается через CMake)

## Основные компоненты

### Класс BinarySearchTree
- Поддерживает все стандартные методы контейнеров STL
- Итераторы с разными стратегиями обхода
- Кастомные компараторы и аллокаторы

### Итераторы
- `const_iterator_` для прямого обхода
- `const_reverse_iterator_` для обратного обхода
- Поддержка инкремента/декремента для разных стратегий

### Узлы
- Шаблонный класс `Node` с поддержкой родительских указателей
- Автоматическое управление памятью

## Особенности реализации

- Использование tag dispatch для выбора стратегии обхода
- Рекурсивное управление памятью без использования STL-контейнеров
- Поддержка семантики перемещения и копирования
- Полная интеграция с алгоритмами STL

## Тестирование

Проект включает комплексные тесты, проверяющие:
- Корректность работы итераторов
- Все стратегии обхода
- Граничные случаи
- Соответствие STL-требованиям
- Работу с пользовательскими компараторами

## Ограничения

- Запрещено использование стандартных контейнеров в реализации
- Требуется полная поддержка стандарта C++17